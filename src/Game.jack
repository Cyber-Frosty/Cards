class Game {
    field boolean gameOn;
	field int previousKey;
	
    field int cursorColumn;
	field int cursorRow;
	field Pile pileTakeFrom;
	field boolean editingSubstack;
	
	field Array tableau;
	field Array stock;
	field Array foundations;
	
	constructor Game new() {
	    var Pile tmpPile;
	    var Card tmpCard;
		var int i;
		
	    let cursorColumn = 0;
		let cursorRow = 1;
		let editingSubstack = false;
		
	    let pileTakeFrom = null;
		
		let stock = Array.new(2);
		let tmpPile = Pile.new(0, 0);
		let tmpCard = Card.new(6, 3, false, false);
		do tmpPile.addCardFirstLayer(tmpCard);
		let tmpCard = Card.new(4, 2, false, false);
		do tmpPile.addCardFirstLayer(tmpCard);
		let tmpCard = Card.new(7, 0, true, false);
		do tmpPile.addCardFirstLayer(tmpCard);
		let stock[0] = tmpPile;
		let stock[1] = Pile.new(1, 0);
		let foundations = Array.new(4);
		let i = 0;
		while (i < 4) {
		    let tmpPile = Pile.new(3 + i, 0);
		    let foundations[i] = tmpPile;
			let i = i + 1;
		}

	    let tableau = Array.new(7);
		let tmpPile = Pile.new(0, 1);
		let tmpCard = Card.new(10, 0, true, true);
		do tmpPile.addCardNewLayer(tmpCard);
		let tmpCard = Card.new(1, 1, true, true);
		do tmpPile.addCardNewLayer(tmpCard);
		let tmpCard = Card.new(13, 3, true, true);
		do tmpPile.addCardNewLayer(tmpCard);
		let tmpCard = Card.new(12, 0, true, true);
		do tmpPile.addCardNewLayer(tmpCard);
		let tableau[0] = tmpPile;

		let i = 1;
		while (i < 7) {
			let tmpPile = Pile.new(i, 1);
			let tableau[i] = tmpPile;
			let i = i + 1;
		}
		
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
		
		return this;
	}
	
	method void runGame() {
	    let gameOn = true;
		while (gameOn) {
		    do processKey();
		}
		
		return;
    }
	
	method void processKey()
	{
	    var int key;
		
		let key = Keyboard.keyPressed();
		if (key = previousKey) {
		    return;
		}
		let previousKey = key;
		
		if (key = 130) { //left
		    do goLeft();
			return;
		}
		if (key = 132) { //right
		    do goRight();
			return;
		}
		if (key = 131) { //up
		    do processUp();
			return;
		}
		if (key = 133) { //down
		    do processDown();
			return;
		}
		if (key = 128) { //enter
		    do processEnter();
			return;
		}
		if (key = 32) { //space
			do moveToFoundation();
			return;
		}
		
		return;
	}
	
	method void processUp() {
	    if (editingSubstack) {
		    do pileTakeFrom.increaseSubstack();
		}
		else {
		    if (~(cursorColumn = 2)) {
			    do goVertically(0);
			}
		}
	    return;
	}
	
	method void processDown() {
	    if (editingSubstack) {
		    do pileTakeFrom.decreaseSubstack();
		}
		else {
		    do goVertically(1);
		}
	    return;
	}
	
	method void processEnter() {
	    if ((cursorRow = 0) & (cursorColumn = 0)) {
		    do scrollStock();
			return;
		}
	    if (pileTakeFrom = null) {
		    do selectSubstack();
		}
		else {
		    if (editingSubstack) {
			    do deselectSubstack();
			}
			else {
			    do moveSubstack();
			}
		}
		return;
	}

	method void scrollStock() {
		var Pile closedStock;
		var Pile openStock;

		var Stack movedStack;
		var Card movedCard;
		var int moveCount;

		let closedStock = stock[0];
		let openStock = stock[1];

		if (closedStock.isEmpty()) {
			do openStock.selectAll();
			let movedStack = openStack.takeCardsToMove();
			let moveCount = movedStack.count();
			while (moveCount > 0) {
				let movedCard = movedStack.pop();
				do closedStock.addCardFirstLayer(movedCard);
				let moveCount = moveCount - 1;
			}
			return;
		}
		do closedStock.select();
		let movedStack = closedStock.takeCardsToMove();
		let movedCard = movedStack.pop();
		do movedCard.open();
		do openStock.addCardFirstLayer(movedCard);

		return;
	}
	
	method void selectSubstack() {
	    let pileTakeFrom = getCurrentPile();
		let editingSubstack = true;
		do Graphics.removeCursor(cursorColumn, cursorRow, 0);
		do pileTakeFrom.select();
		
		return;
	}
	
	method void deselectSubstack() {
		do pileTakeFrom.deselect();
		let pileTakeFrom = null;
		let editingSubstack = false;
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
		
		return;
	}
	
	//todo row col
	method Pile getCurrentPile() {
	    if (cursorRow = 1) {
			return tableau[cursorColumn];
		} else {
			if (cursorColumn < 2) {
				return stock[cursorColumn];
			}
            if (cursorColumn > 2) {
				return foundations[cursorColumn - 3];
			}
		}
		return null;
	}
	
	method void goRight() {
	    var boolean erase;
		var Pile pileOn;
		
	    if (cursorColumn = 6) {
		    return;
		}
		
		if (editingSubstack) {
		    let editingSubstack = false;
		} else {
		    do Graphics.removeCursor(cursorColumn, cursorRow, 0);
		}
		
		let cursorColumn = cursorColumn + 1;
		if ((cursorRow = 0) & (cursorColumn = 2)) {
		    let cursorColumn = 3;
		}
		
		if (~(pileTakeFrom = null)) {
		    let pileOn = getCurrentPile();
			if (pileOn = pileTakeFrom) {
			    let editingSubstack = true;
			    return;
			}
		}
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
	    return;
	}
	
	method void goLeft() {
		var Pile pileOn;
	
	    if (cursorColumn = 0) {
		    return;
		}
		
		if (editingSubstack) {
		    let editingSubstack = false;
		} else {
		    do Graphics.removeCursor(cursorColumn, cursorRow, 0);
		}
		
		let cursorColumn = cursorColumn - 1;
		if ((cursorRow = 0) & (cursorColumn = 2)) {
		    let cursorColumn = 1;
		}
		
		if (~(pileTakeFrom = null)) {
		    let pileOn = getCurrentPile();
			if (pileOn = pileTakeFrom) {
			    let editingSubstack = true;
			    return;
			}
		}
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
	    return;
	}
	
	method void goVertically(int goTo) {
	    var Pile pileOn;
		
	    if (cursorRow = goTo) {
		    return;
		}
		
		if (editingSubstack) {
		    let editingSubstack = false;
		} else {
		    do Graphics.removeCursor(cursorColumn, cursorRow, 0);
		}
		
		let cursorRow = goTo;

		if (~(pileTakeFrom = null)) {
		    let pileOn = getCurrentPile();
			if (pileOn = pileTakeFrom) {
			    let editingSubstack = true;
			    return;
			}
		}
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
	    return;
	}
	
	method void moveSubstack() {
		var int moveCount;
		
	    if (pileTakeFrom = null) {
		    return;
		}
		
		if (cursorRow = 1) {
		    do moveToTableau();
		} 
		else {
		    if (cursorColumn < 3) {
			    return;
			}
			do moveToFoundation();
		}
		
		return;
	}
	
	method void moveToTableau() {
	    var Pile pileTo;
	    var Card bottomCard;
		var Stack toMove;
		var int moveCount;
		
	    let pileTo = tableau[cursorColumn];
		if (pileTo = pileTakeFrom) {
			return;
		}
		
		let bottomCard = pileTakeFrom.getSubstackBottom();
		if (~(pileTo.canAddedToTableau(bottomCard))) {
		    return;
		}
	    
		let toMove = pileTakeFrom.takeCardsToMove();
		let moveCount = toMove.count();
		while (moveCount > 0) {
		    let bottomCard = toMove.getHead();
			do pileTo.addCardNewLayer(bottomCard);
			do toMove.pop();
			let moveCount = moveCount - 1;
		}
		
		let pileTakeFrom = null;
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
		return;
	}
	
	method void moveToFoundation() {
	    var Pile pileTo;
	    var Card movedCard;
		var Card pileCard;
		var Stack toMove;
		var int moveCount;
		var int suit;
		
		if (pileTakeFrom = null) {
		    return;
		}
		
		let moveCount = pileTakeFrom.getSelectedCount();
		
		if (moveCount > 1) {
		    return;
		}
		
		let movedCard = pileTakeFrom.getSubstackBottom();
		let pileTo = foundations[movedCard.getSuit()];
		let pileCard = pileTo.peekCard();
		
		if (pileCard = null) {
		    if (movedCard.getValue() > 1) {
			    return;
			}
		}
		else {
		    if (~(movedCard.getValue() - pileCard.getValue() = 1)) {
			    return;
			}
		}
		
		let toMove = pileTakeFrom.takeCardsToMove();
		do toMove.pop();
	    do pileTo.addCardFirstLayer(movedCard);
		
		let pileTakeFrom = null;
		do Graphics.addCursor(cursorColumn, cursorRow, 0);
		do toMove.dispose();
		return;
	}
}